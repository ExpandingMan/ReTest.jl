var documenterSearchIndex = {"docs":
[{"location":"#ReTest.jl","page":"ReTest.jl","title":"ReTest.jl","text":"","category":"section"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"ReTest is a testing framework for Julia allowing:","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"Defining tests in source files, whose execution is deferred and triggered on demand.\nThis is useful when one likes to have definitions of methods and corresponding tests close to each other. This is also useful for code which is not (yet) organized as a package, and where one doesn't want to maintain a separate set of files for tests.\nFiltering run testsets with a Regex, which is matched against the descriptions of testsets.\nThis is useful for running only part of the test suite of a package. For example, if you made a change related to addition, and included \"addition\" in the description of the corresponding testsets, you can easily run only these tests.\nNote that a pull request exists in the Julia repository to implement regex-filtering for Test.@testset.","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"A couple more features are also enabled, like shuffling the order in which the testsets are run, or running testsets in parallel (via Distributed).","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"ReTest is mostly backward-compatible with Test, i.e. minimal change to test files is necessary in order to switch to ReTest; it's often even possible to use ReTest features without changing a line, e.g. on Julia's Base/stdlib tests), cf. Working with test files which use Test.","category":"page"},{"location":"#Usage","page":"ReTest.jl","title":"Usage","text":"","category":"section"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"The exported ReTest.@testset macro can be used as a direct replacement for Test.@testset (with limitations, see below), and retest() has to be called for the tests to be executed. See retest's docstrings for more details. Moreover, ReTest re-exports (almost) all exported symbols from Test, so there should not be any need to import Test together with ReTest.","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"When using @testset \"inline\", i.e. within the source-code of a package, one can use the InlineTest package instead of ReTest, which only defines the strict minimum and also exports @testset, and therefore loads faster (even if ReTest itself loads fast, it can be desirable to have an even lighter dependency). But ReTest still has to be loaded (as a \"test\" dependency) in order to call retest.","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"Finally, for convenience, ReTest.@testset also implicitly defines a runtests function within the enclosing module, say M, such that M.runtests(...) is equivalent to calling retest(M, ...).","category":"page"},{"location":"#retest-and-@testset","page":"ReTest.jl","title":"retest and @testset","text":"","category":"section"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"CurrentModule = ReTest","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"retest\n@testset","category":"page"},{"location":"#InlineTest.retest","page":"ReTest.jl","title":"InlineTest.retest","text":"retest([m::Module...], pattern = r\"\"; dry::Bool=false, stats::Bool=false,\n                                      shuffle::Bool=false, verbose::Real=true)\n\nRun all the tests declared in @testset blocks, within modules m if specified, or within all currently loaded modules otherwise. If dry is true, don't actually run the tests, just print the descriptions of the testsets which would (presumably) run. If stats is true, print some time/memory statistics for each testset. If shuffle is true, shuffle the order in which top-level testsets within a given module are run, as well as the list of passed modules. If specified, verbose must be an integer or Inf indicating the nesting level of testsets whose results must be printed (this is equivalent to adding the verbose=true annotation to corresponding testsets); the default behavior (true or 1) corresponds to printing the result of top-level testsets.\n\nIt's possible to filter run testsets by specifying pattern: the \"subject\" of a testset is the concatenation of the subject of its parent @testset, if any, with \"/$description\" where description is the testset's description. For example:\n\n@testset \"a\" begin # subject == \"/a\"\n    @testset \"b\" begin # subject is \"/a/b\"\n    end\n    @testset \"c$i\" for i=1:2 # subjects are \"/a/c1\" & \"/a/c2\"\n    end\nend\n\nA testset is guaranteed to run only when its subject matches pattern. Moreover if a testset is run, its enclosing testset, if any, also has to run (although not necessarily exhaustively, i.e. other nested testsets might be filtered out).\n\nIf the passed pattern is a string, then it is wrapped in a Regex with the \"case-insensitive\" flag, and must match literally the subjects. This means for example that \"a|b\" will match a subject like \"a|b\" or \"A|B\", but not like \"a\" (only in Julia versions >= 1.3; in older versions, the regex is simply created as Regex(pattern, \"i\")).\n\nNote: this function executes each (top-level) @testset block using eval within the module in which it was written (e.g. m, when specified).\n\n\n\n\n\n","category":"function"},{"location":"#InlineTest.@testset","page":"ReTest.jl","title":"InlineTest.@testset","text":"@testset args...\n\nSimilar to Test.@testset args..., but the contained tests are not run immediately, and are instead stored for later execution, triggered by runtests(). Invocations of @testset can be nested, but qualified invocations of ReTest.@testset can't. Internally, @testset expressions are converted to an equivalent of Test.@testset at execution time.\n\n\n\n\n\n","category":"macro"},{"location":"#Caveats","page":"ReTest.jl","title":"Caveats","text":"","category":"section"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"ReTest.@testset comes with a couple of caveats/limitations, some of which should be fixable:","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"Toplevel testsets (which are not nested within other testsets), when run, are evaled at the toplevel of their parent module, which means that they can't depend on local variables for example.\n\"testsets-for\" (@testset \"description\" for ...), when run, imply evaling their loop variables at the toplevel of their parent module; this implies that iteration expressions shouldn't depend on local variables (otherwise, the testset subject usually can't be known statically and the testset can't be filtered out with a Regex).\n\"testsets-for\" currently accept only \"non-cartesian\" looping (e.g. for i=I, j=J is not supported, PRs welcome!)\nTestsets can not be \"custom testsets\" (cf. Test documentation).\nNested testsets can't be \"qualified\" (i.e. written as ReTest.@testset).\nRegex filtering logic might improve in future versions, which means that with the same regex, less tests might be run (or more!). See retest's docstring to know which testsets are guaranteed to run.\nDescriptions of testsets must be unique within a module, otherwise they are overwritten and a warning is issued, unless Revise is loaded; the reason is the current implemented heuristic to allow Revise do its magic.","category":"page"},{"location":"#Switching-from-Test-to-ReTest","page":"ReTest.jl","title":"Switching from Test to ReTest","text":"","category":"section"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"When used in a package MyPackage, the test code can be organized as follows:","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"replace using Test by using ReTest in the \"runtests.jl\" file\nwrap the whole content of \"runtests.jl\" within a module named MyPackageTests\nrename \"runtests.jl\" to \"tests.jl\"\ncreate \"runtests.jl\" with the following content: include(\"tests.jl\"); MyPackageTests.runtests()","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"This means that running \"runtests.jl\" will have the same net effect as before. The \"tests.jl\" file can now be included in your REPL session (include(\"tests.jl\")), and you can run all or some of its tests (e.g. MyPackageTests.runtests(\"addition\")).","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"Wrapping the tests in MyPackageTests allows to not pollute Main and keeps the tests of different packages separated. Also, you can modify \"tests.jl\" and re-include it to have the corresponding tests updated (the MyPackageTests module is replaced in Main); otherwise, without a MyPackageTests module, including the file a second time currently triggers a warning for each overwritten toplevel testset.","category":"page"},{"location":"#Filtering","page":"ReTest.jl","title":"Filtering","text":"","category":"section"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"Most of the time, filtering with a simple string is likely to be enough. For example, in","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"@testset \"a\" begin\n    @test true\n    @testset \"b\" begin\n    end\n    @testset \"c\" begin\n    end\nend","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"running retest(M, \"a\") will run everything, retest(M, \"b\") will run @test true and @testset \"b\" but not @testset \"c\". Note that if you want to run @testset \"b\", there is no way to not run @test true in @testset \"a\"; so if it was an expensive test to run, instead of @test true, it could be useful to wrap it in its own testset, so that it can be filtered out.","category":"page"},{"location":"#Running-tests-in-parallel-with-Distributed","page":"ReTest.jl","title":"Running tests in parallel with Distributed","text":"","category":"section"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"Currently, the tests are automatically run in parallel whenever there are multiple workers, which have to be set manually. Running the tests looks like:","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"using Distributed\naddprocs(2)\n@everywhere include(\"test/tests.jl\")\nMyPackageTests.runtests()","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"If the test code doesn't use ReTest (cf. Working with test files which use Test), this can be done as follows:","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"using Distributed\naddprocs(2)\nusing ReTest\n@everywhere begin\n    using ReTest, MyPackage\n    ReTest.hijack(MyPackage)\nend\nMyPackageTests.runtests()","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"note: Note\nAs was already mentioned, testset-for iterators are evaluated at load time in the enclosing module, but this currently happens only in the main process. This can lead to unexpected errors when the package was written without a Distributed use-case in mind.For example, say the package defines a constant singleton object X which is normally equal to itself (because X === X). But if X is assigned to a testset-for loop variable x, it will be the one from the main process, so within the testset-for, a test like x == X might fail because X refers to the singleton object defined in another process; a solution in this case could be to define explicitly == for objects of the type of X.","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"It should be relatively easy to support threaded execution of testsets (it was actually implemented at one point). But it often happens that compiling package code and testset code (which currently is not threaded) takes quite more time than actually running the code, in which case using Distributed has more tangible benefits.","category":"page"},{"location":"#Working-with-Revise","page":"ReTest.jl","title":"Working with Revise","text":"","category":"section"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"When Revise is loaded and a testset is updated, ReTest will observe that a new testset is added with the same description as a previously existing one, which is then overwritten. This works only if the description is not modified, otherwise both the old and new versions of the testset will co-exist.","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"For testsets in a \"script\" loaded with includet, e.g. those in a \"test/tests.jl\" file, you can request Revise to \"load\" the updated testsets by putting __revise_mode__ = :eval in the enclosing module.","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"When files are included recursively, plain includet won't work (it is currently documented to be \"deliberately non-recursive\"). There are two work-arounds:","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"rename your \"test/tests.jl\" file to \"test/MyPackageTests.jl\" and load it as a module (this might involve updating your LOAD_PATH to include \"test/\" and making sure the required packages are found)\nuse the following recursive_includet function instead of includet:","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"function recursive_includet(filename)\n    already_included = copy(Revise.included_files)\n    includet(filename)\n    newly_included = setdiff(Revise.included_files, already_included)\n    for (mod, file) in newly_included\n        Revise.track(mod, file)\n    end\nend","category":"page"},{"location":"#Working-with-test-files-which-use-Test","page":"ReTest.jl","title":"Working with test files which use Test","text":"","category":"section"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"It's sometimes possible to use ReTest features on a test code base which uses Test, without modifications:","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"if you have a package Package, you can try ReTest.hijack(Package), which will define a PackageTests module when successful, on which you can call retest.\nif you have a test file \"testfile.jl\", try ReTest.hijack(\"testfile.jl\") (this will define a fresh module like above).","category":"page"},{"location":"","page":"ReTest.jl","title":"ReTest.jl","text":"ReTest.hijack","category":"page"},{"location":"#ReTest.hijack","page":"ReTest.jl","title":"ReTest.hijack","text":"ReTest.hijack(source, [modname]; parentmodule::Module=Main)\n\nGiven test files defined in source using the Test package, try to load them by replacing Test with ReTest, wrapping them in a module modname defined within parentmodule. If successful, the newly created module modname is returned and modname.runtests() should be callable.\n\nIf source::AbstractString, then it's interpreted as the top level test file (possibly including other files), and modname defaults to an arbitrary name.\n\nIf source::Module, then it's interpreted as the name of a package, and the \"test/runtests.jl\" file from this package is loaded. In this case, modname defaults to Symbol(source, :Tests).\n\nThe current procedure is as follows:\n\nreplace toplevel using Test occurrences by using ReTest (using can have multiple arguments);\napply recursively these two rules for all included files, provided the include statement is at the toplevel.\n\n\n\n\n\n","category":"function"}]
}
